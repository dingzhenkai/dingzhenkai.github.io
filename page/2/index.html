<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="丁星乐、学习、工作、生活" />
   
  <meta name="description" content="分享丁星乐的学习、工作与享乐时光" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     丁星乐
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/dingzhenkai"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover.jpg" alt="image frame" />
    </div>
    <div style="color:#000" class="cover-inner text-center text-white">
      <h1><a style="color:#000" href="/">丁星乐</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>


<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-write-resume-skills" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/02/16/write-resume-skills/"
    >简历写作技巧</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/02/16/write-resume-skills/" class="article-date">
  <time datetime="2021-02-16T06:20:38.000Z" itemprop="datePublished">2021-02-16</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>转自 阿里校招群某位大佬的建议</p>
<blockquote>
<p>各位同学好，我们阿里开源核心产品Nacos创始人，近期评估简历发现很多小伙伴写的简历太平淡，给出我一些建议，欢迎小伙伴投简历给我一起交流<br>我的邮箱： <a href="mailto:water.lyl@alibaba-inc.com">water.lyl@alibaba-inc.com</a><br>我的微信：lylolyl  流水<br>写简历怎么写出差异化竞争力？<br>1、有项目经历：参加公司、导致真实的xx项目，采用了xx技术，解决了xx难题<br>2、有竞赛经历：获得了什么结果，竞赛中挑战的题目是，采用什么技术，算法解决。<br>3、有开源经历：参与xx开源项目，贡献多少核心代码，可以把贡献代码负载简历上<br>4、有优秀论文：攻克了软件领域的难题，并且在xx发表<br>5、有博客积累：学习经验和编码程序有积累，可以附在简历上</p>
</blockquote>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zkdingme.github.io/2021/02/16/write-resume-skills/" data-id="ckqi0khp5002enfj50b2g38j6"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%80%E5%8E%86%E5%86%99%E4%BD%9C/" rel="tag">简历写作</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Code-Style" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/21/Code-Style/"
    >Code Style整理</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/21/Code-Style/" class="article-date">
  <time datetime="2021-01-20T17:27:54.000Z" itemprop="datePublished">2021-01-21</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ol>
<li><p>文件<br>驼峰命名法(小驼峰) 例如 initRoom.js  index.js</p>
</li>
<li><p>类<br>驼峰命名法(大驼峰) 例如 LoginAction</p>
</li>
<li><p>函数</p>
<p>驼峰命名法(小驼峰) 例如 initRoom</p>
</li>
<li><p>变量<br>驼峰命名法(小驼峰) curCount</p>
</li>
<li><p>常量<br>驼峰命名法(大驼峰) MaxCount</p>
</li>
</ol>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul>
<li>删除一个对象不能仅仅靠解绑引用，等GC；要手动强制删除对象 ，但是手动强制删除对象也会有问题，万一哪里忘记删除引用，程序就会挂，不过开发阶段挂也没事。</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>参数校验<br>统一在函数内部对参数进行校验，校验失败在函数返回值里面体现</li>
<li>error<br>函数内部遇到错误时，如果是函数自己运行生成的error，统一向上抛</li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>一个类不应该直接访问另一个类的属性，而是应该封装一个函数给外部类调用<br>例如class Referee 想访问 class Battle的status [waiting, going, end]，不能直接访问battleObj.status，而是应该调用battleObj.isWaiting(), battleObj.isGoing(), battleObj.isEnd()</li>
<li>对象之前允许套娃引用。worker 创建了 room，然后转发消息给room， room如果突然要把消息传给worker的话，两种方式：其一，函数返回值，worker 里面 ret = worker.onReceiveMessage(msg) ；其二，在room里面加一个指向worker的引用，然后在 room里面调用 worker.onReceiveRoomMessage。第二种方式更好，不要怕引用产生套娃，没事的，面向对象是可以这样的。</li>
</ul>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zkdingme.github.io/2021/01/21/Code-Style/" data-id="ckqi0khob000bnfj5e8yc8im4"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Code-Style/" rel="tag">Code Style</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Linux-shell-符号" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/13/Linux-shell-%E7%AC%A6%E5%8F%B7/"
    >Linux_shell_符号</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/13/Linux-shell-%E7%AC%A6%E5%8F%B7/" class="article-date">
  <time datetime="2021-01-13T14:43:26.000Z" itemprop="datePublished">2021-01-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>转载：<a href="https://zhuanlan.zhihu.com/p/101752614" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/101752614</a> 和 <a href="https://www.cnblogs.com/eshizhan/archive/2011/11/30/2269325.html" target="_blank" rel="noopener">https://www.cnblogs.com/eshizhan/archive/2011/11/30/2269325.html</a></p>
<p>在用linux命令时候,我们可以一行执行多条命令或者有条件的执行下一条命令，下面我们讲解一下linux命令分号&amp;&amp;和&amp;，|和||的用法</p>
<p><strong>“;”分号用法</strong></p>
<p>方式：command1 ; command2</p>
<p>用;号隔开每个命令, 每个命令按照从左到右的顺序,顺序执行， 彼此之间不关心是否失败， 所有命令都会执行。</p>
<p><strong>“| ”管道符用法</strong></p>
<p>上一条命令的输出，作为下一条命令参数</p>
<p>方式：command1 | command2</p>
<p>Linux所提供的管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为 第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推</p>
<p>利用一个管道<br># rpm -qa|grep licq<br>这条命令使用一个管道符“|”建立了一个管道。管道将rpm -qa命令的输出（包括系统中所有安装的RPM包）作为grep命令的输入，从而列出带有licq字符的RPM包来。</p>
<p>利用多个管道<br># cat /etc/passwd | grep /bin/bash | wc -l<br>这条命令使用了两个管道，利用第一个管道将cat命令（显示passwd文件的内容）的输出送给grep命令，grep命令找出含有“/bin /bash”的所有行；第二个管道将grep的输出送给wc命令，wc命令统计出输入中的行数。这个命令的功能在于找出系统中有多少个用户使用bash</p>
<p><strong>“&amp;”符号用法</strong></p>
<p>&amp;放在启动参数后面表示设置此进程为后台进程</p>
<p>方式：command1 &amp;</p>
<p>默认情况下，进程是前台进程，这时就把Shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个’&amp;’实现这个目的。</p>
<p><strong>“&amp;&amp;”符号用法</strong></p>
<p>shell 在执行某个命令的时候，会返回一个返回值，该返回值保存在 shell 变量 $? 中。当 $? == 0 时，表示执行成功；当 $? == 1 时（我认为是非0的数，返回值在0-255间），表示执行失败。</p>
<p>有时候，下一条命令依赖前一条命令是否执行成功。如：在成功地执行一条命令之后再执行另一条命令，或者在一条命令执行失败后再执行另一条命令等。shell 提供了 &amp;&amp; 和 || 来实现命令执行控制的功能，shell 将根据 &amp;&amp; 或 || 前面命令的返回值来控制其后面命令的执行。</p>
<p>语法格式如下：</p>
<p>command1 &amp;&amp; command2 [&amp;&amp; command3 …]</p>
<p>命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。<br>只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。<br>只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。</p>
<p><strong>“||”符号用法</strong></p>
<p>逻辑或的功能</p>
<p>语法格式如下：</p>
<p>command1 || command2 [|| command3 …]</p>
<p>命令之间使用 || 连接，实现逻辑或的功能。<br>只有在 || 左边的命令返回假（命令返回值 $? == 1），|| 右边的命令才会被执行。这和 c 语言中的逻辑或语法功能相同，即实现短路逻辑或操作。<br>只要有一个命令返回真（命令返回值 $? == 0），后面的命令就不会被执行。 –直到返回真的地方停止执行。</p>
<p>举例，ping命令判断存活主机</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ping -c 1 -w 1 192.168.1.1 &amp;&gt; /dev/null &amp;&amp; result=0 ||result=1</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$result</span>"</span> == 0 ];<span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"192.168.1.1 is UP!"</span>    </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"192.168.2.1 is DOWN!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>注意 &amp;&gt;要连起来写。</p>
<p><strong>“`”符号用法</strong></p>
<p>位置：反引号（`）这个字符一般在键盘的左上角，数字1的左边，与（~）在同一键上，不要将其同单引号（’）混淆</p>
<p>作用：反引号括起来的字符串被shell解释为命令行，在执行时，shell首先执行该命令行，并以它的标准输出结果取代整个反引号（包括两个反引号）部分</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[eshizhan@localhost usr]$ echo &#96;date&#96;</span><br><span class="line">2011年 11月 30日 星期三 16:37:23 CST</span><br></pre></td></tr></table></figure>

<p><strong>“$”符号用法</strong></p>
<p>与反引号`类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $(date)</span><br></pre></td></tr></table></figure>






      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zkdingme.github.io/2021/01/13/Linux-shell-%E7%AC%A6%E5%8F%B7/" data-id="ckqi0khoi000knfj5230v02zh"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/shell/" rel="tag">shell</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-docker-volume迁移" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/25/docker-volume%E8%BF%81%E7%A7%BB/"
    >docker容器迁移—volume迁移</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/11/25/docker-volume%E8%BF%81%E7%A7%BB/" class="article-date">
  <time datetime="2020-11-25T12:30:20.000Z" itemprop="datePublished">2020-11-25</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/docker/">docker</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>问题描述：出于性能考虑，我们准备将elasticsearch服务(用docker部署)迁移到一台配置更高的机器，所以就需要将elasticsearch里面的数据传到新的机器上并重新挂载然后重新服务。</p>
<h2 id="数据存储路径是什么"><a href="#数据存储路径是什么" class="headerlink" title="数据存储路径是什么"></a>数据存储路径是什么</h2><p>这里建议看下<a href="https://docs.docker.com/storage/" target="_blank" rel="noopener">docker官方文档对于数据管理的说明</a>。</p>
<p>这个要看一开始你的容器配置。</p>
<p>如果你的容器启动时没有挂载任何目录，那么所有的数据都是储存在容器实例里面。以elasticsearch为例，数据存储在elasticsearch容器的<code>/usr/share/elasticsearch/data</code>目录下。这时候要把数据pull出来是一件比较困难的事情，一般这个时候就直接迁移整个container了。</p>
<p>把数据(以数据分析场景为例就是数据分析程序、原属log数据、分析结果)存储在容器内其实是一种不正确的容器使用方式。docker容器其实就是个runtime，容器里面不应该放跟runtime无关的东西。例如你可以在一个elasticsearch的容器里面配置新的python，但是没必要把你写的数据处理的python脚本也放进去，python脚本应该mount到容器上。并且读写container内的数据性能是比读写本地文件差的，参考<a href="https://docs.docker.com/storage/storagedriver/" target="_blank" rel="noopener">docker storagedriver文档</a>。</p>
<p>docker支持三种mount方式: volume、bind mount和tmpfs mount。这三种方式的共同点是他们都是把本地文件系统的空间mount到docker容器上，docker和host都可以对这部分空间进行读写造作，不同点在于到底是mount的host上的哪部分空间。</p>
<p><img src="https://docs.docker.com/storage/images/types-of-mounts.png" alt=""></p>
<p>这是docker文档上介绍三种mount方式的图，可以明显看出三者mount方式的异同。</p>
<ul>
<li><p>volume<br>volume方式是在host文件系统上分配给docker的目录内新建一个目录，然后将这个目录挂载到容器上。linux上这个目录是<code>/var/lib/docker/volumes</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">volume</span> <span class="comment"># volume 挂载</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">elasticsearch</span></span><br><span class="line">        <span class="attr">target:</span> <span class="string">/usr/share/elasticsearch/data</span></span><br></pre></td></tr></table></figure>

<p>这里docker就会在<code>/var/lib/docker/volumes</code>目录下新建一个elasticsearch目录，然后将这个目录mount到容器上。<br>docker命令行也提供了一些命令来管理volume:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">xxxxx@xxxx:~$ docker volume COMMAND --help</span><br><span class="line"></span><br><span class="line">Usage:	docker volume COMMAND</span><br><span class="line"></span><br><span class="line">Manage volumes</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volumes</span><br><span class="line">  prune       Remove all unused local volumes</span><br><span class="line">  rm          Remove one or more volumes</span><br><span class="line"></span><br><span class="line">Run 'docker volume COMMAND --help' for more information on a command.</span><br></pre></td></tr></table></figure>
</li>
<li><p>bind mount<br>bind mount可以挂载文件系统上任意一个目的到容器，例如<code>/home/xxx/docker-elastic-mount</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">bind</span> <span class="comment"># bind mount</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">/home/xxx/docker-elastic-mount</span></span><br><span class="line">        <span class="attr">target:</span> <span class="string">/usr/share/elasticsearch/data</span></span><br></pre></td></tr></table></figure>

<p>这里就把/home/xxx/docker-elastic-mount目录挂载到elasticsearch容器上，elasticsearch的数据都会存储到这个文件夹。bind mount方式相比于volume方式，优点在于可选的目录范围更广，并且host也可以对挂载的空间进行读写。volume方式挂载时目录只允许docker进行读写，host除非是root用户否则不能读写。</p>
</li>
<li><p>tmpfs mount<br>tmpfs mount是把内存里面的一块区域mount到容器上。这个读写肯定是最快的，但是显然也不可扩展，内存就那么大，而且一旦断电，数据也都没了。</p>
</li>
</ul>
<p>综上，如果是为了迁移方面考虑的话，推荐bind mount的方式。</p>
<h2 id="怎么快速并且完整的将数据传到新机器上"><a href="#怎么快速并且完整的将数据传到新机器上" class="headerlink" title="怎么快速并且完整的将数据传到新机器上"></a>怎么快速并且完整的将数据传到新机器上</h2><p>数据从老机器同步到新机器推荐用rsync进行同步，rsync同步的时候不会改变文件的权限，并且传输过程中还可以压缩，降低导出流量。</p>
<p>rsync -avzhP src des</p>
<h2 id="如何重新挂载"><a href="#如何重新挂载" class="headerlink" title="如何重新挂载"></a>如何重新挂载</h2><p>当数据目录同步到新机器上后，就可以用bind mount的方式重新挂载上去，例如</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">bind</span> <span class="comment"># bind mount</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">/home/xxx/docker-elastic-mount</span></span><br><span class="line">        <span class="attr">target:</span> <span class="string">/usr/share/elasticsearch/data</span></span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，如果你的老机器是volume挂载的，你是把老机器上/var/lib/docker/volumes里面的volume同步到新机器上然后bind mount，会有一个权限问题。volume的权限是drwxr-xr-x，只有root才可以读写，所以需要改一下权限。</p>
<p>最简单的方法是<code>chmod -R 777 &lt;volume&gt;</code>，当然这非常不安全。推荐还是改一下文件拥有者<code>chown -R whoami:groups &lt;volume&gt;</code>。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zkdingme.github.io/2020/11/25/docker-volume%E8%BF%81%E7%A7%BB/" data-id="ckqi0khot0018nfj5dkow8jk9"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/volume/" rel="tag">volume</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-adbuninstall与在桌面卸载的区别" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/22/adbuninstall%E4%B8%8E%E5%9C%A8%E6%A1%8C%E9%9D%A2%E5%8D%B8%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB/"
    >adb install&amp;uninstall 原理</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/11/22/adbuninstall%E4%B8%8E%E5%9C%A8%E6%A1%8C%E9%9D%A2%E5%8D%B8%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2020-11-22T06:39:53.000Z" itemprop="datePublished">2020-11-22</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>adb: failed to install app-release.apk: Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package io.appetizer.secsensedev signatures do not match previously installed version; ignoring!]</p>
<p>最近测试一款App时，遇到这样一个问题：同一个App有一个debug包和一个release包，这两个包签名的证书是不一样的。我在华为Mate30上先<code>adb install app-debug.apk</code>，测试完成后直接在桌面长按卸载(注意这里不是adb uninstall卸载)，然后我继续<code>adb install app-release.apk</code>，但这会报错了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb: failed to install app-release.apk: Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package XXX signatures do not match previously installed version; ignoring!]</span><br></pre></td></tr></table></figure>

<p>看报错信息是签名不一致导致的，应该是手机里面保留了&lt;pkgname, signatures&gt;这样的数据，简单说就是没卸载干净。然后我使用<code>adb uninstall XXX</code>卸载了一下，在安装release包就可以了。看上去是adb uninstall卸载的更干净一点，之后我在雷电模拟器replay这个过程，发现没有这样的问题，雷电模拟器的桌面卸载就可以把签名信息留存也给删了。</p>
<p>深究这个错误就得到了如下几个问题：</p>
<ol>
<li>adb install的过程是什么，会读写那些文件(华为手机的adb install的时候应该就会读取留存的&lt;pkgname, signatures&gt;文件然后跟新包对比签名)</li>
<li>adb uninstall的过程是什么，会读写哪些文件</li>
<li>华为手机的卸载过程是什么，会读写哪些文件</li>
<li>除华为外其他各家包括模拟器的卸载过程是什么，与adb uninstall区别</li>
</ol>
<p>好这几个问题，我们有空再探讨，目前2020/11/22没空。</p>
<p>参考 <a href="http://blog.hjhjw1991.com/android/2018/01/02/Apk%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">http://blog.hjhjw1991.com/android/2018/01/02/Apk%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E5%8E%9F%E7%90%86/</a></p>
<p><a href="https://blog.csdn.net/new_abc/article/details/7435508" target="_blank" rel="noopener">https://blog.csdn.net/new_abc/article/details/7435508</a></p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zkdingme.github.io/2020/11/22/adbuninstall%E4%B8%8E%E5%9C%A8%E6%A1%8C%E9%9D%A2%E5%8D%B8%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB/" data-id="ckqi0khop000xnfj55vwk9wj6"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/adb/" rel="tag">adb</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-制作U盘系统盘" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/21/%E5%88%B6%E4%BD%9CU%E7%9B%98%E7%B3%BB%E7%BB%9F%E7%9B%98/"
    >制作U盘系统盘</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/11/21/%E5%88%B6%E4%BD%9CU%E7%9B%98%E7%B3%BB%E7%BB%9F%E7%9B%98/" class="article-date">
  <time datetime="2020-11-21T07:32:28.000Z" itemprop="datePublished">2020-11-21</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>目标：制作一个ubuntu 18.04的u盘系统盘</p>
<p>步骤如下：</p>
<ol>
<li><p>Windows下载安装<a href="https://rufus.akeo.ie/" target="_blank" rel="noopener">refus</a></p>
</li>
<li><p>去<a href="http://releases.ubuntu.com/18.04.4/" target="_blank" rel="noopener">官网</a> 下载<a href="http://old-releases.ubuntu.com/releases/18.04.4/ubuntu-18.04-desktop-amd64.iso" target="_blank" rel="noopener">desktop版的ubuntu</a>，注意这里的amd64就是x86-64</p>
</li>
<li><p>将u盘插入电脑，启动refus，界面如下<br><img src="refus-1.jpg" alt=""><br>其中设备显示的就是你插入的U盘</p>
</li>
<li><p>选择ubuntu iso文件 引导类型选择——镜像文件(请选择)——选择——选中你的iso文件<br><img src="refus-2.jpg" alt=""><br>引导类型(bootloader)：bootloader 是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核准备好正确的环境。<br>下面的FreeDOS、Syslinux、ReactOS、Grub、UEFI:NTFS都是一些引导程序选项，这里面大家熟悉的估计就是Grub了，GNU GRUB（GRand Unified Bootloader简称“GRUB”）是一个来自GNU项目的多操作系统启动程序。GRUB是多启动规范的实现，它允许用户可以在计算机内同时拥有多个操作系统，并在计算机启动时选择希望运行的操作系统。简单说，你想装双系统，你的bootloader基本就是Grub。<br><img src="refus-3.jpg" alt=""><br>持久分区大小(Persistent partition size): 这个分区用来存储你使用U盘里的linux系统(try linux/ubuntu)时的changes, 例如新建一个文件。如果你不需要try linux，就设置为0.<br><img src="refus-4.jpg" alt=""><br>分区类型(MBR/GPT)：<a href="https://blog.51cto.com/groot/1842985" target="_blank" rel="noopener">详解</a><br>目标系统类型(BIOS/UEFI): <a href="https://www.zhihu.com/question/21672895" target="_blank" rel="noopener">详解</a><br><img src="refus-5.jpg" alt=""><br>文件系统(FAT32/NTFS)：<a href="https://zhuanlan.zhihu.com/p/32364955" target="_blank" rel="noopener">详解</a><br><img src="refus-6.jpg" alt=""></p>
</li>
<li><p>刷入iso文件</p>
<p><img src="refus-7.jpg" alt=""></p>
</li>
</ol>
<p>这样我们就得到了一个u盘系统盘。</p>
<p>参考 <a href="https://blog.51cto.com/jk6627/1967667" target="_blank" rel="noopener">https://blog.51cto.com/jk6627/1967667</a><br><a href="https://www.zhihu.com/question/28471913" target="_blank" rel="noopener">https://www.zhihu.com/question/28471913</a></p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zkdingme.github.io/2020/11/21/%E5%88%B6%E4%BD%9CU%E7%9B%98%E7%B3%BB%E7%BB%9F%E7%9B%98/" data-id="ckqi0khp7002nnfj5hlck5oj8"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B6%E4%BD%9Cu%E7%9B%98%E7%B3%BB%E7%BB%9F%E7%9B%98/" rel="tag">制作u盘系统盘</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-POSIX规范介绍" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/18/POSIX%E8%A7%84%E8%8C%83%E4%BB%8B%E7%BB%8D/"
    >POSIX规范介绍</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/11/18/POSIX%E8%A7%84%E8%8C%83%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2020-11-18T08:13:39.000Z" itemprop="datePublished">2020-11-18</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%9D%82%E8%B0%88/">计算机基础杂谈</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>wikipedia定义：</p>
<blockquote>
<p><strong>可移植操作系统接口</strong>（英语：Portable Operating System Interface，缩写为<strong>POSIX</strong>）是<a href="https://zh.wikipedia.org/wiki/IEEE" target="_blank" rel="noopener">IEEE</a>为要在各种<a href="https://zh.wikipedia.org/wiki/UNIX" target="_blank" rel="noopener">UNIX</a><a href="https://zh.wikipedia.org/wiki/操作系统" target="_blank" rel="noopener">操作系统</a>上运行软件，而定义<a href="https://zh.wikipedia.org/wiki/API" target="_blank" rel="noopener">API</a>的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为<a href="https://zh.wikipedia.org/wiki/ISO" target="_blank" rel="noopener">ISO</a>/<a href="https://zh.wikipedia.org/wiki/IEC" target="_blank" rel="noopener">IEC</a> 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由<a href="https://zh.wikipedia.org/wiki/理查德·斯托曼" target="_blank" rel="noopener">理查德·斯托曼</a>（RMS）应IEEE的要求而提议的一个易于记忆的名称。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而<strong>X</strong>则表明其对Unix API的传承。</p>
<p><a href="https://zh.wikipedia.org/wiki/Linux" target="_blank" rel="noopener">Linux</a>基本上逐步实现了POSIX兼容，但并没有参加正式的POSIX认证。<a href="https://zh.wikipedia.org/wiki/可移植操作系统接口#cite_note-1" target="_blank" rel="noopener">[1]</a></p>
<p><a href="https://zh.wikipedia.org/wiki/微软" target="_blank" rel="noopener">微软</a>的<a href="https://zh.wikipedia.org/wiki/Windows_NT" target="_blank" rel="noopener">Windows NT</a>声称部分实现了POSIX标准。</p>
<p>当前的POSIX主要分为四个部分<a href="https://zh.wikipedia.org/wiki/可移植操作系统接口#cite_note-2" target="_blank" rel="noopener">[2]</a>：Base Definitions、System Interfaces、Shell and Utilities和Rationale。</p>
</blockquote>
<p>《深入理解计算机系统》第二版 p11</p>
<blockquote>
<p>20世纪60年代是大型、复杂操作系统盛行的年代，比如IBM的OS/360和Honeywell的Multics系统。OS/360是历史上最成功的软件项目之一，而 Multics虽然持续存在了多年，却从来没有被广泛应用过。贝尔实验室曾经是Multics项目的最初参与者，但是因为考虑到该项目的复杂性和缺乏进展而于1969年退出。鉴于Mutics项目不愉快的经历，一群贝尔实验室的研究人员Ken Thompson、 Dennis Ritchie、 Doug Mcllroy和 Joe Ossanna，从1969年开始在DEC PDP-7计算机上完全用机器语言编写了一个简单得多的操作系统。这个新系统中的很多思想，比如层次文件系统、作为用户级进程的 shell概念，都是来自于 Multics，只不过在一个更小、更简单的程序包里实现。1970年，Brian Kernighan给新系统命名为“Unix”，这也是一个双关语，暗指“Multics”的复杂性。1973年用C重新编写其内核，1974年，Unix开始正式对外发布。</p>
<p>贝尔实验室以慷慨的条件向学校提供源代码，所以Unix在大专院校里获得了很多支持并得以持续发展。最有影响的工作发生在20世纪70年代晚期到80年代早期，在美国加州大学伯克利分校，研究人员在一系列发布版本中增加了虚拟内存和Internet协议，称为Unix4.xBSD(Berkeley Software Distribution)。与此同时，贝尔实验室也在发布自己的版本，称为System V Unix。其他厂商的版本，比如Sun Microsystems的Solaris系统,则是从这些原始的BSD和System V版本中衍生而来。</p>
<p>20世纪80年代中期，Unix厂商试图通过加入新的、往往不兼容的特性来使它们的程序与众不同，麻烦也就随之而来了。为了阻止这种趋势，IEEE(电气和电子工程师协会)开始努力标准化Unix的开发，后来由 Richard Stallman命名为“Posix”。结果就得到了一系列的标准，称作Posix标准。这套标准涵盖了很多方面，比如Unix系统调用的C语言接口、shell程序和工具、线程及网络编程。最近，一个被称为“标准Unix规范”的独立标准化工作已经与Posix一起创建了统一的Unix系统标准。这些标准化工作的结果是Unix版本之间的差异已经基本消失。</p>
</blockquote>
<p>简单说，POSIX是一个规范，规范操作系统对应用层提供的API。背景是当时Unix碎片化，各家厂商都维护自家的Unix系统，给自家Unix里面加各种特色功能，导致应用层软件开发者们很无奈，所以IEEE站出来说，为了软件开发者们少操心，大家统一一下接口。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zkdingme.github.io/2020/11/18/POSIX%E8%A7%84%E8%8C%83%E4%BB%8B%E7%BB%8D/" data-id="ckqi0khom000nnfj524019xe7"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/POSIX/" rel="tag">POSIX</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计算机安全术语概念" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E6%9C%AF%E8%AF%AD%E6%A6%82%E5%BF%B5/"
    >计算机安全术语概念</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E6%9C%AF%E8%AF%AD%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2020-11-17T04:35:45.000Z" itemprop="datePublished">2020-11-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/">计算机安全</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>转载 <a href="https://blog.csdn.net/qq_37622608/article/details/88048847" target="_blank" rel="noopener">https://blog.csdn.net/qq_37622608/article/details/88048847</a></p>
<p><strong>1.POC</strong></p>
<p><code>POC，Proof ofConcept</code>，中文意思是“<code>观点证明</code>”。这个短语会在漏洞报告中使用，漏洞报告中的POC则是<code>一段说明或者一个攻击的样</code>例，使得读者能够确认这个漏洞是真实存在的。<br><strong>2.EXP</strong></p>
<p><code>EXP</code>，Exploit，中文意思是“<code>漏洞利用</code>”。意思是一段对漏洞<code>如何利用的详细说明或者一个演示的漏洞攻击代码</code>，可以使得读者完全了解漏洞的机理以及利用的方法。<br><strong>3.VUL</strong></p>
<p><code>VUL</code>，Vulnerability的缩写，泛指<code>漏洞</code>。<br><strong>4.CVE漏洞编号</strong></p>
<p><code>CVE</code> 的英文全称是“Common Vulnerabilities &amp; Exposures”公共漏洞和暴露，例如CVE-2015-0057、CVE-1999-0001等等。CVE就好像是一个字典表，为广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称。如果在一个漏洞报告中指明的一个漏洞，如果有CVE名称，你就可以快速地在任何其它CVE兼容的数据库中找到相应修补的信息，解决安全问题。</p>
<p>可以在<a href="https://cve.mitre.org/网站根据漏洞的CVE编号搜索该漏洞的介绍。" target="_blank" rel="noopener">https://cve.mitre.org/网站根据漏洞的CVE编号搜索该漏洞的介绍。</a></p>
<p>也可以在中文社区<a href="http://www.scap.org.cn/上搜索关于漏洞的介绍" target="_blank" rel="noopener">http://www.scap.org.cn/上搜索关于漏洞的介绍</a></p>
<p><strong>5.0DAY漏洞和0DAY攻击</strong></p>
<p>在计算机领域中，零日漏洞或零时差漏洞（英语：Zero-dayexploit）通常是指还没有补丁的安全漏洞，而零日攻击或零时差攻击（英语：Zero-dayattack）则是指利用这种漏洞进行的攻击。提供该漏洞细节或者利用程序的人通常是该漏洞的发现者。零日漏洞的利用程序对网络安全具有巨大威胁，因此零日漏洞不但是黑客的最爱，掌握多少零日漏洞也成为评价黑客技术水平的一个重要参数。<br>零日漏洞及其利用代码不仅对犯罪黑客而言，具有极高的利用价值，一些国家间谍和网军部队，例如美国国家安全局和美国网战司令部也非常重视这些信息[1]。据路透社报告称美国政府是零日漏洞黑市的最大买家。</p>
<p><strong>6.APT攻击</strong></p>
<p>APT攻击是一个集合了多种常见攻击方式的综合攻击。综合多种攻击途径来尝试突破网络防御，通常是通过Web或电子邮件传递，利用应用程序或操作系统的漏洞，利用传统的网络保护机制无法提供统一的防御。除了使用多种途径，高级定向攻击还采用多个阶段穿透一个网络，然后提取有价值的信息，这使得它的攻击更不容易被发现。</p>
<p><strong>7.ARP攻击</strong></p>
<p>地址解析协议，即ARP（Address Resolution Protocol），是根据<a href="https://baike.baidu.com/item/IP地址" target="_blank" rel="noopener">IP地址</a>获取<a href="https://baike.baidu.com/item/物理地址/2129" target="_blank" rel="noopener">物理地址</a>的一个<a href="https://baike.baidu.com/item/TCP%2FIP协议" target="_blank" rel="noopener">TCP/IP协议</a>。<a href="https://baike.baidu.com/item/主机/455151" target="_blank" rel="noopener">主机</a>发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个<a href="https://baike.baidu.com/item/ARP欺骗" target="_blank" rel="noopener">ARP欺骗</a>。<a href="https://baike.baidu.com/item/ARP命令" target="_blank" rel="noopener">ARP命令</a>可用于查询本机ARP缓存中IP地址和<a href="https://baike.baidu.com/item/MAC地址" target="_blank" rel="noopener">MAC地址</a>的对应关系、添加或删除静态对应关系等。相关协议有<a href="https://baike.baidu.com/item/RARP" target="_blank" rel="noopener">RARP</a>、<a href="https://baike.baidu.com/item/代理ARP" target="_blank" rel="noopener">代理ARP</a>。<a href="https://baike.baidu.com/item/NDP" target="_blank" rel="noopener">NDP</a>用于在<a href="https://baike.baidu.com/item/IPv6" target="_blank" rel="noopener">IPv6</a>中代替地址解析协议。</p>
<p><strong>8.ROP攻击</strong></p>
<p>ROP全称为Return-oriented Programming（面向返回的编程）是一种新型的基于代码复用技术的攻击，攻击者从已有的库或可执行文件中提取指令片段，构建恶意代码。</p>
<p>ROP的核心思想：攻击者扫描已有的<a href="https://baike.baidu.com/item/动态链接库/100352" target="_blank" rel="noopener">动态链接库</a>和可执行文件，提取出可以利用的指令片段(gadget)，这些指令片段均以ret指令结尾，即用ret指令实现指令片段执行流的衔接。操作系统通过栈来进行函数的调用和返回。函数的调用和返回就是通过压栈和出栈来实现的。每个程序都会维护一个程序运行栈，栈为所有函数共享，每次函数调用，系统会分配一个栈桢给当前被调用函数，用于参数的传递、局部变量的维护、返回地址的填入等。栈帧是程序运行栈的一部分 ，在<a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>中 ，通过%esp和 %ebp寄存器维护栈顶指针和栈帧的起始地址 ，%eip是程序计数器寄存器 [1] 。而ROP攻击则是利用以ret结尾的程序片段 ，操作这些栈相关寄存器，控制程序的流程，执行相应的gadget，实施攻击者预设目标 。ROP不同于retum-to-libc攻击之处在于，ROP攻击以ret指令结尾的函数代码片段 ，而不是整个函数本身去完成预定的操作。从广义角度讲 ，return-to-libc攻击是ROP攻的特例。最初ROP攻击实现在x86体系结构下，随后扩展到各种体系结构.。与以往攻击技术不同的是，ROP恶意代码不包含任何指令，将自己的恶意代码隐藏在正常代码中。因而，它可以绕过W⊕X的防御技术。</p>
<p><strong>9.buffer overflow攻击</strong></p>
<p><a href="https://baike.baidu.com/item/缓冲区" target="_blank" rel="noopener">缓冲区</a>溢出是指当<a href="https://baike.baidu.com/item/计算机/140338" target="_blank" rel="noopener">计算机</a>向缓冲区内填充数据位数时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。理想的情况是：程序会检查数据长度，而且并不允许输入超过缓冲区长度的字符。但是绝大多数程序都会假设数据长度总是与所分配的储存空间相匹配，这就为缓冲区溢出埋下隐患。操作系统所使用的缓冲区，又被称为“<a href="https://baike.baidu.com/item/堆栈" target="_blank" rel="noopener">堆栈</a>”，在各个操作进程之间，指令会被临时储存在“堆栈”当中，“堆栈”也会出现<a href="https://baike.baidu.com/item/缓冲区溢出/678453" target="_blank" rel="noopener">缓冲区溢出</a>。</p>
<p><strong>10.RCE漏洞</strong></p>
<p>远程代码执行漏洞</p>
<p>该生热爱祖国、热爱集体，拥护中国共产党的领导，在日常学习生活中，起到党员模范带头作用，政治立场坚定，组织观念强，坚决贯彻党的路线方针政策。<br>该生在研究生期间学习努力认真，已完成研究生毕业的学分要求。成绩优异。在实验室里刻苦钻研，踏实肯干，具有较强的科研能力和实践能力，目前已完成巨型虚拟机项目，发表小论文1篇，毕业设计方向为数据中心与分布式系统。<br>该生勤俭节约，尊重师长，团结同学，积极参加班级活动，与同学们相处融洽。<br>综上所述，该生在校期间各方面表现良好。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zkdingme.github.io/2020/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E6%9C%AF%E8%AF%AD%E6%A6%82%E5%BF%B5/" data-id="ckqi0khpc0033nfj54odz9c10"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%AF%E8%AF%AD/" rel="tag">术语</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-外卖客户端容器化架构的演进" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/13/%E5%A4%96%E5%8D%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%B9%E5%99%A8%E5%8C%96%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/"
    >外卖客户端容器化架构的演进</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/11/13/%E5%A4%96%E5%8D%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%B9%E5%99%A8%E5%8C%96%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/" class="article-date">
  <time datetime="2020-11-13T13:21:13.000Z" itemprop="datePublished">2020-11-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">移动端</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>转载自：<a href="https://tech.meituan.com/2020/09/30/waimai-mobile-architecture-evolution.html" target="_blank" rel="noopener">https://tech.meituan.com/2020/09/30/waimai-mobile-architecture-evolution.html</a></p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><h3 id="1-1-移动端跨平台技术的介绍"><a href="#1-1-移动端跨平台技术的介绍" class="headerlink" title="1.1 移动端跨平台技术的介绍"></a>1.1 移动端跨平台技术的介绍</h3><p>移动端的跨平台技术不是一个新话题，早在几年前，WebView容器、React Native、Weex、Flutter、小程序等移动端跨平台框架就风起云涌。为什么跨平台这么有吸引力呢？我们设想一下如果可以做到一次开发，多端复用，那么对于公司来说，就可以降低用人成本。对于开发来说，只需要学习一个框架，就可以在Android和iOS双平台上开发。节约下来的成本，可以投入到产品快速验证、快速上线。这对所有人来说都有着极大的吸引力。本节先针对部分移动端跨平台技术进行一些简要的介绍，以便读者能够更好地理解后面的内容。</p>
<p><strong>1.1.1 WebView容器</strong></p>
<p>WebView容器的工作原理是基于Web技术来实现界面和功能，通过将原生的接口封装、暴露给JavaScript调用，JavaScript编写的页面可以运行在系统自带的WebView中。这样做的优势是，对于前端开发者比较友好，可以很快地实现页面跨端，同时保留调用原生的能力，通过搭建桥接层和原生能力打通。但这种设计，跨端的能力受限于桥接层，当调用之前没有的原生能力时，就需要增加桥。另外，浏览器内核的渲染独立于系统组件，无法保证原生体验，渲染的效果会差不少。</p>
<p><img src="https://p0.meituan.net/travelcube/77f8d98aad413e1719d922e3257d412544108.png@850w_402h_80q" alt="img"></p>
<p><strong>1.1.2 React Native</strong></p>
<p>2015年，Facebook推出了React Native，一经推出就备受关注。它的思路是最大化地复用前端的生态和Native的生态，和WebView容器的最大区别在于View的渲染体系。React Native抛弃了低效的浏览器内核渲染，转而使用自己的DSL生成中间格式，然后映射到对应的平台，渲染成平台的组件。相对WebView容器，体验会有一定的提升。不过，渲染时需要JavaScript和原生之间通信，在有些场景可能会导致卡顿。另外就是，渲染还是在Native层，要求开发人员对Native有一定的熟悉度。</p>
<p><img src="https://p0.meituan.net/travelcube/9c145086754d4c2b5eb01765aa6c6d18107147.png@1708w_910h_80q" alt="img"></p>
<p><strong>1.1.3 Flutter</strong></p>
<p>2018年Google推出Flutter，通过Dart语言构建一套跨平台的开发组件，所有组件基于Skia引擎自绘，在性能上可以和Native平台的View相媲美。Flutter站在前人的肩膀上，参考了React的状态管理、Web的自绘制UI、React Native的HotReload等特点，同时考虑了与Native通信的Channel机制、自渲染、完备的开发工具链。Flutter与上述Recat Native、WebView容器本质上都是不同的，它没有使用WebView、JavaScript解释器或者系统平台自带的原生控件，而是有一套自己专属的Widget，底层渲染使用自身的高性能C/C++ 引擎自绘。但大部分移动端发展到今天，都已经形成了自己的架构，在现有基础上加上Flutter，会形成原有架构和Flutter双平台共存的问题。目前，对新的App来说，是最被看好的跨端方案。</p>
<p><img src="https://p0.meituan.net/travelcube/579adf74deddadca7bed046bbdf8670d24344.png@809w_474h_80q" alt="img"></p>
<h3 id="1-2-美团外卖业务介绍"><a href="#1-2-美团外卖业务介绍" class="headerlink" title="1.2 美团外卖业务介绍"></a>1.2 美团外卖业务介绍</h3><p>作为中国领先的生活服务电子商务平台，美团致力于用科技连接消费者和商家，提供服务以满足人们日常“吃”的需求，并进一步扩展至多种生活和旅游服务。而作为公司最为重要的业务之一，美团外卖从2013年创建以来，已经从单一的品类扩展到附近美食、水果、蔬菜、超市、鲜花、蛋糕等多品类，从早午晚餐，发展到下午茶、宵夜，中餐、西餐、家常菜、小吃、快餐、海鲜、火锅、川菜、蛋糕、烤肉、水果、饮料、甜点等多种类餐饮。美团外卖可以说是当前电商领域，最为复杂的业务之一。</p>
<p>业务的复杂，给系统架构也带来了不小的挑战。美团外卖业务之所以说是当前电商领域最为复杂的业务，主要源于以下几点特征：</p>
<ul>
<li>美团外卖业务承载在三个App上，美团外卖App、美团App外卖频道、点评App外卖频道。</li>
<li>美团外卖作为美团公司重要的用户入口，还承担着流量平台的作用，提供平台能力支撑频道业务的发展，如闪购、跑腿、金融等。</li>
<li>美团外卖作为已经成熟的业务，需提供可复用的平台能力，支撑新业务的发展，例如菜大全App的发展。</li>
<li>美团外卖作为一个超级业务方，业务内又运营多个方向业务，如流量业务、交易业务、商家业务、商品业务、营销业务、广告业务等。</li>
</ul>
<p>综上所述，可以发现美团外卖不仅仅自身业务比较复杂，而且对外的角色也很复杂。在美团内部，外卖不仅仅是美团平台的一个频道业务，而且自己本身也是一个平台业务，同时美团外卖还承担着新业务发展的平台角色。这意味着想要支持好美团外卖业务的发展是一件非常有挑战的事情。</p>
<h3 id="1-3-美团外卖移动端历史架构概述"><a href="#1-3-美团外卖移动端历史架构概述" class="headerlink" title="1.3 美团外卖移动端历史架构概述"></a>1.3 美团外卖移动端历史架构概述</h3><p>好的架构源于不停地衍变而非设计。美团外卖的架构，历史上也是经历了很多次迭代。由于外卖业务形态不断地发生变化，原有的设计也需要不断地跟随业务形态进行演进。在不断探索和实践过程中，我们经历了若干个大的架构变迁。从考虑如何高效地复用代码支持外卖App，逐渐地衍变成如何去解决多端代码复用问题，再从多端的代码复用到支持其他频道业务的平台架构上。在平台化架构建设完成后，我们又开始尝试利用动态化技术去支持业务快速上线的诉求。如今，我们面临着多端复用、平台能力、平台支撑、单页面多业务团队、业务动态诉求强等多个业务场景问题。下文我们针对美团外卖移动端架构的变迁史，做一些简单的概述，以便读者阅读本文时能有更好的延续性。</p>
<p><strong>1.3.1 组件化架构</strong></p>
<p>早期阶段，美团外卖作为公司的一个孵化业务，在2013年底完成了美团外卖App的1.0版本。随着外卖业务的验证成功和跑通，订单量也快速增长，在2014年底突破了日订单量100万。随后在2015年2月，外卖以Native的形式接入美团App，成为美团App的一个业务频道。在接入过程中，我们从美团外卖App拷贝了大量的代码到美团App的外卖频道，两个App上的外卖业务代码也分别由两个独立的团队维护。早期外卖业务变化快，App迭代频繁，写代码的方式也比较粗放，同时美团App也处在一个平台化转变的时期，代码的稳定性和质量都在变化和提升当中。这些因素导致了外卖代码内各子系统之间耦合严重，边界模糊，“你中有我，我中有你”的情况随处可见。这对代码质量、功能扩展以及开发效率都造成很大的影响。此时，我们架构重构的目的，就是希望将各个子系统划分为相对独立的组件，建设组件可以直接复用，架构如下图所示：</p>
<p><img src="https://p0.meituan.net/travelcube/819767b8ffd73aa544654d8809f5e29e122940.png@1026w_788h_80q" alt="img"></p>
<p><strong>1.3.2 平台化架构</strong></p>
<p>如上文所述，大家可以知道美团外卖和美团外卖频道是由不同的团队在维护发展。2015年，公司考虑到业务发展的一致性，将美团外卖频道团队正式归于美团外卖。从组织架构上来说，美团外卖和美团外卖频道，逐渐融合成一个团队，但是两端的差异性，导致我们不得不仍然阶段性地维持原有的两班人马，各自去维护独立外卖App和美团外卖频道。如何解决这个问题？两端代码复用看起来是唯一的途径。另外，随着业务的快速发展，外卖App所承载的业务模块越来越多，产品功能越来越复杂，团队规模也越来越大，如闪购、跑腿等业务想以独立的Native包的形态接入外卖App，还有外卖的异地研发团队的建立，都带来了挑战。这使得我们在2017年开始了第二次架构重构——平台化架构，目标是希望能够支持多端复用和支持不同团队的业务发展。通过抽象出平台能力层、业务解耦、建立壳容器，最终实现了平台化架构，架构如下图所示：</p>
<p><img src="https://p1.meituan.net/travelcube/79a8a4e3205e291d0afdfbd34193ec78164627.png@1582w_918h_80q" alt="img"></p>
<p><strong>1.3.3 RN混合架构</strong></p>
<p>在平台化架构之后，美团外卖功能持续增加，美团外卖客户端安装包的体积也在持续增加。回顾2017年和2018年，每年几乎都增长100%。如果没有一个有效的手段，安装包将变得越发臃肿。另外，由于原生应用需要依托于应用市场进行更新，每次产品的更新，必须依赖用户的主动更新，使得版本的迭代周期很长。业务上的这些痛点，不断地督促我们去反思到底有没有一种框架可以解决这些问题。</p>
<p>在2015年的时候，Facebook发布了非常具有颠覆性的React Native框架，简称RN。从名字上看，就可以清楚的明白，这是混合式开发模式，RN使用Native来渲染，JS来编码，从而实现了跨平台开发、快速编译、快速发布、高效渲染和布局。RN作为一种跨平台的移动应用开发框架，它的特性非常符合我们的诉求。美团也积极的探索RN技术。在RN的基础上，美团在脚手架、组件库、预加载、分包构建、发布运维等方面进行了全面的定制及优化，大幅提升RN的开发及发布运维效率，形成了MRN（Meituan React Native）技术体系。</p>
<p>从2018年开始，美团外卖客户端团队开始尝试使用MRN框架来解决业务上的问题。使用RN的另一方面的好处是，能逐渐的抹平Android和iOS开发技术栈带来的问题，使用一套代码，两个平台上线，理论上人效可以提升一倍，支持的业务需求也可以提升一倍，架构如下图所示：</p>
<p><img src="https://p1.meituan.net/travelcube/1036f256e52c2d2a582c801ce7d410b3171224.png@1582w_992h_80q" alt="img"></p>
<h2 id="2-美团外卖容器化架构全景图"><a href="#2-美团外卖容器化架构全景图" class="headerlink" title="2. 美团外卖容器化架构全景图"></a>2. 美团外卖容器化架构全景图</h2><h3 id="2-1-什么是容器化架构"><a href="#2-1-什么是容器化架构" class="headerlink" title="2.1 什么是容器化架构"></a>2.1 什么是容器化架构</h3><p>上文说到，外卖业务已经发展到多App复用、单页面多业务团队开发的业务阶段。要满足这样的业务场景下，寻求一个可持续发展的业务架构是件不容易的事情。经过我们之前架构演进，我们获得了宝贵的经验：在平台化架构的时候，我们将App和业务进行解耦，将App做成壳容器，业务形成独立的业务库，集成到壳容器里面，从而屏蔽了多App的问题，提高了业务的复用度。在RN混合式架构里面，我们引入了RN容器，通过这个容器，使得业务屏蔽了Android和iOS的平台差异。借助这些成功的经验，我们进一步思考，如果我们尝试进一步的细分外卖的业务场景，将不同场景下的基础能力建设成壳容器，业务集成到容器内，是否可以更好的支撑我们多App复用、单页面多业务团队的当前现状呢？</p>
<p><strong>容器化架构的愿景是</strong>：</p>
<ul>
<li>希望将前端呈现业务的环境抽象出来，将能力进行标准化，形成统一的容器，通过容器去屏蔽平台和端的差异。容器提供上层标准统一的能力接口，使得业务开发人员专注于容器内的业务逻辑的实现，最大复用已有的能力，而不用关注现在的环境是Android还是iOS，现在的端是美团App还是大众点评App。</li>
<li>容器和远端达成呈现协议，使得端上的内容具备随时可变化的能力。容器化架构的实现是存在一定前提的，如果业务的发展本身处在一个探索阶段，还有较多可变的因素，是无法形成稳定的能力层的，这时候建设容器化架构反而使得架构偏向复杂。但对于外卖业务场景来说，经过多年的沉淀固定，外卖业务逐渐形成了一套稳定的业务形态，已经进入到场景细分和快速迭代业务模块的阶段。在这样的阶段下，容器化架构才有可实施的前提。</li>
</ul>
<h3 id="2-2-容器化架构的优势"><a href="#2-2-容器化架构的优势" class="headerlink" title="2.2 容器化架构的优势"></a>2.2 容器化架构的优势</h3><p>当我们把承载外卖业务的环境进行了抽象和标准化后，就可以获得以下若干点好处。首先动态化属性提升，我们可以把原有必须在客户端上写的业务放到了远端，业务的动态性得到很大的提升，具备随时上线业务的可能。对于开发过程而言，编译部署的速度也得到了极大提升。如果涉及到客户端的代码改动，那客户端的编译打包，即使是增量的编译，也至少是秒级的编译速度。而容器化后，我们只打包必要的业务，把业务动态下发到容器呈现，客户端代码本身不会有变化，这样就可以从秒级的编译减少到毫秒级的编译。同样，业务动态下发，对减少客户端的包大小也有很大的帮助。</p>
<p>然后，容器位于应用之内，我们向应用中引入相同的容器SDK，容器屏蔽了应用之间的差异，对于Android和iOS平台，在设计上，通过容器这一层去尽可能屏蔽平台之间的差异，使业务开发人员只需要认识容器，不需要花费大量的精力去关注应用和平台之间的差异，从而使得开发效率得到了极大的提升。</p>
<p>其次，容器化后，容器对承载的内容是有接口协议要求的，承载的内容只有满足容器定义的协议才能得到容器带来的好处，这促使业务得到了更细粒度的细分，业务开发时候，对模块化的意识得到了保障。另外，容器这一层提供的接口在Android和iOS上是标准化的，业务的开发也因为依赖的标准化，而趋向标准化，双端的业务一致性得到了提升。这些潜在的架构好处，对未来的业务维护和扩展都打下了比较好的地基。</p>
<h3 id="2-3-外卖容器化架构全景图"><a href="#2-3-外卖容器化架构全景图" class="headerlink" title="2.3 外卖容器化架构全景图"></a>2.3 外卖容器化架构全景图</h3><p><img src="https://p0.meituan.net/travelcube/b145dba75e4687b23302add1439d2364423893.png@1582w_992h_80q" alt="img"></p>
<p>整个外卖容器化架构可以按照从下到上，从左到右的视角进行解读：</p>
<p>最底层是系统服务，因为我们采用了H5和RN这样跨端的技术栈，使得iOS系统和Android系统成为了最底层。</p>
<p>系统服务之上是集团基于Native建设的基建，全公司通用，覆盖了研发工程中方方面面的基础服务。</p>
<p>在基建之上是我们定义的容器层。我们尝试用单一技术栈解决所有问题。但经过我们的探索，觉得不太可能实现。好的架构要匹配业务形态，业务的诉求决定了我们不能选择唯一的技术栈去解决所有问题，细分外卖的业务场景可得到以下3个方向的页面分类：</p>
<ul>
<li>高PV主流程页面，例如首页、金刚页、商家页等，这类页面的PV远高于其他页面。这类页面的特点是，交互强、曝光度高、多团队参与建设和维护。针对这类页面，为了给用户提供极致的体验，是无法采用H5或RN实现的，即使性能上能够满足，但是这些页面是多团队共同参与建设，如果用H5或RN实现，那么单一团队改动，都会造成全页面受到无法预料的影响，其他未改动的业务方肯定是无法接受的。所以这类页面，我们采用的是局部动态化+页面模块化的方案，我们针对页面进行容器化改造，将页面变成容器，容器承载模块。每个模块归不同的业务方进行维护，从模块的维度进行解耦，每个模块都可以动态配置和下发。</li>
<li>低PV辅助页面，例如帮助、足迹、收藏等，这类页面的PV低，但胜在数量多，都用原生实现成本比较高，如果都用H5来实现，不少页面和原生的关联还是比较近，不是非常适合。针对这类页面，我们采用集团提供的MRN基建去承载，MRN作为跨端的技术栈，我们已经在之前的RN混合架构的时候，建设了较为丰富的组件，针对自定义的MRN容器做了比较丰富的建设。同时，MRN具备动态下发的能力，满足业务的诉求。</li>
<li>向外投放的运营活动页面，例如圣诞节活动，时效性比较强。这类页面由H5技术栈去完成，一方面可以满足时效性，另一方面H5的动态下发能力也是最强的，这样的特性能够充分的满足业务的诉求。我们使用集团提供的Titans基建，通过建设业务自定义的Titans容器，支撑业务的发展。</li>
</ul>
<p>再往上，就是垂直的业务，外卖目前有流量业务、交易业务、商家业务、商品业务、广告业务、营销业务、闪购业务等。业务都是垂直向下依赖，直接可见容器，可见基建，能够很好地获取到各种已经建设的能力去完成业务的需求。</p>
<p>最上面是承载的App端，目前有四端，包括外卖、点评、美团、闪购等等。</p>
<p>右侧是测试发布和线上监控，相对于常规的移动端App架构而言，容器化架构的测试发布和监控是更为精细化的。不仅仅要关注端本身的可用性，还需要关注容器、容器承载的模块、模块展示的模板，模板里面的样式这些的可用性。</p>
<h3 id="2-4-容器化的挑战"><a href="#2-4-容器化的挑战" class="headerlink" title="2.4 容器化的挑战"></a>2.4 容器化的挑战</h3><p>容器化架构相对常规的移动端架构而言，它从管理移动端的代码转变成管理移动端的容器建设代码和业务远端开发代码，多出了容器和业务远端下发。这不仅仅是对技术上的挑战，对长期做客户端开发同学，也需要一个思维转变的跳转。</p>
<p><strong>一致性的挑战</strong>：容器需要在多个宿主应用之中运行，宿主应用的环境一致性直接影响了容器的一致性。我们的策略是两手准备，一方面利用外卖业务的优势推动宿主应用的环境对齐；另一方面将容器建设成SDK，通过SDK将长期保持容器的一致性，也通过SDK内部的设计屏蔽应用之间的差异；对于Android和iOS平台，我们通过分层的设计，尽可能屏蔽平台的差异。综上所述，一致性的挑战在于（1）容器运行的宿主应用的环境一致性；（2）不同应用不同版本容器的一致性；（3）Android和iOS平台容器的对业务的一致性。</p>
<p><strong>动态发布的挑战</strong>：长期以来，客户端同学的开发概念里面只有App版本的概念，而当我们逐渐把业务代码做成远端下发时，将会新增一个线上动态发版的概念。当我们在发布业务的时候，相对以往的工作，多出需要去考虑这个业务的版本，可以运行的容器对应的App上下界版本。另外，发版的周期也会新增业务的发版周期，不仅仅是App的发版周期。这两者在一起将会产生新的火花，业务的版本和App的版本如何适配的问题，业务动态发版的周期和App的发版周期如何适配的问题。外卖这边的解决方式是建设主版本迭代+周迭代的模型。</p>
<p><strong>监控运维的挑战</strong>：以往的移动端架构，我们更加关注的是端本身的可用性，然而当我们演进到容器化架构的时候，仅仅关注端的可用性已经远远不能确定业务是可用的了。我们需要从端的可用性延伸出下载链路、加载链路，使用链路上的可用性，针对每个重要的环境，都做好监控运维。</p>
<h2 id="3-外卖跨端容器建设"><a href="#3-外卖跨端容器建设" class="headerlink" title="3. 外卖跨端容器建设"></a>3. 外卖跨端容器建设</h2><h3 id="3-1-MRN容器"><a href="#3-1-MRN容器" class="headerlink" title="3.1 MRN容器"></a>3.1 MRN容器</h3><p><strong>3.1.1 MRN容器简介</strong></p>
<p>React Native框架本身只是一个运行时环境中的渲染引擎，可以将同一套JS代码分别在Android和iOS系统上最终以Native的方式渲染页面，从而为App提供了基础的跨端能力。但从工程化的角度来看，如果想在App中大规模地应用RN技术，除了RN框架本身外，还需要在开发、构建、测试、部署、运维等诸多方面的配合。MRN（Meituan React Native）是美团基于React Native框架改造并完善而成的一套动态化方案，在RN的基础上提供了容器化能力、动态化能力、多端复用能力和工程化保障。MRN在开发效率、稳定性、性能体验、动态化和监控运维等多方面进行了能力升级和扩展，满足了美团RN开发工程化的需要。目前，MRN已接入美团40多个App，核心框架及生态工具有超过100位内部代码贡献者，总PV超过4亿。</p>
<p><img src="https://p0.meituan.net/travelcube/ecd3acd6c6f7600cbaae6b58d7e49b23222108.png@2182w_790h_80q" alt="img"></p>
<p><strong>3.1.2 Roo组件库</strong></p>
<p>下面再介绍一下外卖建设的两个UI相关的技术项目，Roo组件库和组件样式动态配置。</p>
<ul>
<li><strong>Roo组件库</strong>：外卖在RN及MRN框架提供的UI组件基础之上，又扩展了适用于外卖业务的标准化UI组件库。UI组件库一方面统一了我们的设计规范和开发规范，提高了UI一致性；另一方面，组件封装也提升了RN页面的开发效率和质量。</li>
<li><strong>组件样式动态配置</strong>：有了标准的Roo组件，我们进一步给标准组件的动态添加了样式动态配置能力。在使用组件时，很多样式是支持动态下发的，例如字体、圆角、背景色等，方便我们进行UI的适配和改版。</li>
</ul>
<p><img src="https://p0.meituan.net/travelcube/349ecc07bc28bb684986eda81c4bc91f126530.png@1420w_846h_80q" alt="img"></p>
<p>外卖在2018年底开始试验MRN容器在外卖业务上的应用，并在2019年上半年进行了大面积的页面落地。目前，外卖已有近60个RN页面上线，占外卖页面比例超80%，其中包括Tab页面“我的”、提单选择红包页、订单评价页等高PV页面。MRN容器的接入，给外卖App的容器化、动态化、人效提升、包大小瘦身等方面都做出了不小的贡献。</p>
<h3 id="3-2-Titans容器"><a href="#3-2-Titans容器" class="headerlink" title="3.2 Titans容器"></a>3.2 Titans容器</h3><p><strong>3.2.1 Titans容器简介</strong></p>
<p>Titans容器是美团系App统一的Web容器组件，基于苹果提供的WebView组件，将WebView容器化，统一了WebView的UI展示和交互方式，规范了桥协议的使用范式，同时预置了诸多基础能力和业务能力。Titans容器大大提高了Web页面的开发效率和用户体验上的一致性。</p>
<p><img src="https://p0.meituan.net/travelcube/63914a69ebf328920b15c8df1bc4a75d78578.png@1408w_480h_80q" alt="img"></p>
<ul>
<li><strong>Web容器</strong>：Titans容器提供了统一的UI展示和自定义样式，例如导航栏样式、页面Loading状态、进度条样式等；还有统一的交互方式，例如页面跳转、Scheme协议的解析等。</li>
<li><strong>KNB统一桥服务</strong>：Web容器虽然在动态化和Android、iOS双端复用上很好地弥补了Native的不足，但在很多地方体验上又难以达到Native的标准。因此，KNB桥应运而生，KNB定义了Native和JS通信的标准方式，方便开发时进行桥协议扩展，同时KNB也内置众多的Native基础能力，极大地提高了Titans容器的用户体验和开发效率。</li>
<li><strong>Web业务增强能力</strong>：Titans容器中预置了丰富的基础业务页面，例如登录页面、分享弹窗等。</li>
<li><strong>提供链路增强</strong>：提供了长连接、离线化等方式来提高网络请求的速度和成功率。</li>
<li><strong>WebView预加载</strong>：在App启动之后，用户点击网页入口之前，提前加载好HTML主文档和基础库，这样当用户点击页面入口时，App直接使用已准备好的WebView，仅需加载少量的业务代码。从而达到白屏时间短、加载页面迅速的效果。</li>
</ul>
<p>Titans容器在外卖业务中的使用场景非常丰富，其中最重要的使用场景是各种运营页和活动页，例如点击首页顶部Banner的广告落地页、为你优选、限时秒杀等活动运营页等；还有客服页、帮助反馈页、商家入驻页、美团公益页等功能性页面；作为一级入口页面的美团会员页面，也是一个基于Enlight的Titans容器。</p>
<h2 id="4-外卖页面容器建设"><a href="#4-外卖页面容器建设" class="headerlink" title="4. 外卖页面容器建设"></a>4. 外卖页面容器建设</h2><p>外卖容器化建设，首先需要要区分的是核心页面和非核心页面。外卖业务中对核心页面的定义是页面DAU&gt;美团DAU的5%或者是下单关键路径。为什么要先按照是否为核心页面进行拆分呢？重点就在于改造的成本。核心页面的业务复杂度决定了它不容易做全页面的动态化，它比较适合做局部的动态化方案。核心页面的复杂度在于业务本身复杂，最重要的是核心页面往往会有多个垂直业务团队共同的开发维护，大家各自有重点关注的模块，做全页面的动态化，无法做到有效的物理隔离。</p>
<p>而对于非核心页面，业务功能和交互相对简单，组织关系也较为确定，更适合做标准的MRN和Titans容器化。所以我们的策略是核心页面做到支撑页面模块级别的业务动态和复用，非核心页面可以做到页面级别的动态化和复用。页面容器化的核心含义就是把一个页面划分为若干个模块，每个模块成为一个业务容器，每个容器的填充既可以用Native的方式实现，也可以用Mach实现（Mach是外卖自研的页面局部动态化技术），可以支持iOS/Android/小程序三端跨平台运行。页面本身则化身为容器的管理者，负责子容器的编排和布局，并支持其动态化。</p>
<h3 id="4-1-页面容器化设计思路"><a href="#4-1-页面容器化设计思路" class="headerlink" title="4.1 页面容器化设计思路"></a>4.1 页面容器化设计思路</h3><p><img src="https://p0.meituan.net/travelcube/5a1e777c3bed15faeb78c54993e9662d101409.png@1920w_424h_80q" alt="img"></p>
<p>页面容器化设计中主要分为三个阶段，模块有序化、模块编排化、渐进式业务落地。</p>
<ul>
<li><strong>模块有序化</strong>：将耦合的外卖业务代码按模块维度进行拆分，建立标准化的模块间组合和交互方案，降低模块内改动对其他模块的影响。这个阶段我们同时完成了Native原生模块和局部动态化模块的标准化改造。</li>
<li><strong>模块编排化</strong>：页面容器化的一个特点是页面具备编排模块的能力，在这个阶段我们在客户端增加了对业务模块结构编排能力的支持，同时我们跟后端的同学共建了配置平台，通过配置化的方式打通了AB实验平台、统一数据服务等多个平台。在标准化的数据协议的支撑下，页面支持了AB实验动态上线，大大降低了客户端在AB实验方面的开发成本，做到了客户端零成本，后端低成本，高效地支撑了外卖首页六周年的大改版。</li>
<li><strong>渐进式业务落地</strong>：页面容器化后最明显的收益是支持业务需求的动态上线，只有页面容器中的业务模块具备动态能力才能实现这个目标，这会涉及Native模块迁移为Mach模块的过程。在这个方面，我们的思路是跟随业务需求渐进式落地。在模块编排阶段，我们设计了Native模块向Mach模块迁移的能力，同时设计了覆盖模板维度和API接口维度的三重降级方案，来保障模块动态化迁移的稳定性。</li>
</ul>
<h3 id="4-2-业务构建模块标准化"><a href="#4-2-业务构建模块标准化" class="headerlink" title="4.2 业务构建模块标准化"></a>4.2 业务构建模块标准化</h3><p>从App页面开发的角度看，一个完整的页面可以按照不同的功能及不同业务属性划分出多个不同的模块。</p>
<p>业务构建泛指由多个业务模块组合拼装为一个业务页面的过程，涉及页面本身（UIViewController/Activity）以及各个业务模块的构造过程，前后端业务数据以及页面和业务模块之间的数据交互过程，业务模块内部的数据处理以及视图刷新流程。</p>
<p>模块标准化指的将业务构建涉及到的多个过程通过规范化的方式确定下来，形成唯一的标准。模块标准化一方面能够在解决业务共性问题的基础上提供业务难点专项解决方案，另一方面能够在框架基础上形成能力约束，减少重复建设、低质量建设的问题。</p>
<p>业务构建模块标准化中我们抽象了四层，下面将分别进行解读。</p>
<p><img src="https://p0.meituan.net/travelcube/f997b81ac6737ed76ff4e09b88fcd858284873.png@1302w_1062h_80q" alt="img"></p>
<ul>
<li>最底层是框架能力层，是外卖业务团队自研的符合外卖业务特点的双端模块化框架。框架解决了不同页面场景下的共性问题，对典型的业务痛点也进行了支持。它是一种页面框架设计在iOS、Android双端对齐的实现方案，这种双端对齐的能力为页面容器化设计的双端一致性提供了保障。</li>
<li>统一接口层是对框架能力层的标准化抽象，它可以保证任一模块调用的能力在各个业务场景下的实现都是一致的，有了这一层抽象任一模块都可以直接在各个场景下复用。</li>
<li>在往上就是App全局的模块复用层，标准化后的模块可以通过唯一标示向模块复用池注册模块，这种中心化的注册方式可以让业务模块在跨业务库的场景下可以灵活地复用。</li>
<li>最上层就是外卖的核心业务场景层，每一个场景都对应了一个标准化的页面容器，页面容器通过实现容器化接口来完成页面容器的构建。</li>
</ul>
<p>通过业务构建模块标准化的建设，业务模块已经是标准化的了，可以在跨页面间自由组合，这为页面容器化打下了基础。</p>
<p>在页面容器化中最基础的能力有以下几点：页面中业务模块可编排能力，动态上线前端AB实验的能力，增量上线动态模块的能力。实现这些能力最重要的就是进行前后端数据协议标准化建设。客户端根据数据协议中的模块唯一标识匹配并构造业务模块，在完成模块数据的填充后会根据数据协议中的模块布局信息完成模块的布局。针对Mach动态模块，我们创建了基于模板ID的模块匹配和数据填充流程，可以支持Mach动态模板的增量上线。在数据协议中针对前端AB实验我们预留了AB实验和通参字段，在数据填充阶段通过容器化接口传入动态模块中，用于支持AB实验的动态上线。</p>
<p>在容器化上线的过程中属于接口的大版本升级，为了保证容器的高可用性，客户端从模块级别和API级别实现了两套降级容灾方案。</p>
<p>模块级别的降级方案主要针对Mach动态模块，与Native模块不同，Mach动态模块需要预先下载动态模板才能正常地完成模块的载入和渲染。为了保证动态模块的加载成功率，我们一方面在接口上线前利用Eva（美团内部系统）对Mach模板的下载进行预热。另一方面，我们设计了动态模块的主动降级方案，针对动态模块的动态上线使用Native模块进行兜底降级，对于跟版动态模块使用App内置模板的方案进行兜底降级。</p>
<p>API级别的容灾方案主要为了保障客户端在新接口不稳定的情况下可以自行降级到旧接口。针对这个问题，我们对线上老接口设计了数据结构映射方案，在客户端通过配置化的方式可以把老接口的数据结构映射为新接口的数据结构。这样在上层业务无感知的情况下，可以做到容灾方案的上下线。</p>
<h3 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h3><p>通过页面容器化，使得页面只需要关心页面级的构造方式，而无需关心某一模块内部如何实现动态化的。把页面与页面的模块分离，也符合目前外卖客户端的组织结构，有利于业务组间的协作。同时，页面容器化使得外卖核心页面具备了符合外卖业务场景下的动态能力，渐进式把Native静态模块过渡到具备动态能力的模块，从模块的维度使整个页面具备了动态能力。这种渐进式的迁移方案把容器迁移跟业务模块的迁移分隔开，大大降低了页面容器化改造的风险。</p>
<h2 id="5-外卖容器化架构的衡量指标"><a href="#5-外卖容器化架构的衡量指标" class="headerlink" title="5. 外卖容器化架构的衡量指标"></a>5. 外卖容器化架构的衡量指标</h2><h3 id="5-1-容器化架构衡量指标的特点"><a href="#5-1-容器化架构衡量指标的特点" class="headerlink" title="5.1 容器化架构衡量指标的特点"></a>5.1 容器化架构衡量指标的特点</h3><p>质量和性能指标是衡量我们App开发质量和用户体验的重要依据，是我们一直都非常关注的重点数据。在非容器化时代，我们大多数的指标都和App的使用环节紧密相关，因为在非容器化时代，逻辑链路相对简单，例如我们打开一个新页面时，我们首先创建页面实例，然后发起网络请求，同时页面会经历一系列生命周期方法，最后渲染。这时我们可能会关注网络请求的成功率和请求时间，页面的渲染时间，和过成功是否发生Crash，这个过程相对更短暂，指标更少，所以监控起来也更容易。</p>
<p>外卖的容器化大大提升了外卖业务的复用能力、动态能力、模块化和开发效率，但同时也带来了更长的逻辑链路，链路从时间维度上划分是：下载链路、加载链路、使用链路。例如我们在使用MRN容器的时候，会涉及到bundle的启动下载或预热下载，bundle解压缩，MRN容器引擎初始化，bundle加载，JS的加载、执行，页面渲染等步骤，其中的每个步骤都可能存在性能问题和质量风险。因此，我们需要升级我们的衡量指标系统来应对容器化带来的新的挑战。</p>
<p><img src="https://p1.meituan.net/travelcube/d5b7d8744122dcb220058cd937f01fbb335369.png@2066w_1368h_80q" alt="img"></p>
<h3 id="5-2-链路指标"><a href="#5-2-链路指标" class="headerlink" title="5.2 链路指标"></a>5.2 链路指标</h3><ul>
<li><strong>下载链路</strong>：在下载链路中下载容器所需的各种资源，在MRN和Mach中主要是bundle的下载任务，只有bundle下载成功，才能进行后面的各项操作。所以bundle下载的成功率是下载链路中最重要的指标，同时bundle下载的时机也很重要。外卖业务中有各种bundel上百个，如果在启动时拉取所有bundle，对冷启动时间会造成极大的影响。我们采用了bundle预热的方法，发布bundle是给bundle打上相应的Tag，在适当的时机去下载，避免集中下载。</li>
<li><strong>加载链路</strong>：在加载链路中重要工作是对下载链路中下载的资源的解压和解析。例如在用PGA加载页面时，会进行模块的解析、模块匹配、模块降级、数据模型生成等步骤。在MRN中会进行bundle解压、引擎初始化、bundle加载等步骤。加载链路往往是比较消耗计算资源的步骤，对页面打开和加载时间影响较大，所以我们会比较关注加载链路的性能指标。</li>
<li><strong>使用链路</strong>：使用链路和非容器化的使用阶段基本相同，会主要关注页面的加载时间、Crash率、页面页面FPS、页面卡顿等指标。除此之外，还会关注和容器本身特性相关的一些指标，例如在MRN容器中，我们还会关注JS错误率、JS渲染时间、白屏率等指标。</li>
</ul>
<h3 id="5-3-关键指标"><a href="#5-3-关键指标" class="headerlink" title="5.3 关键指标"></a>5.3 关键指标</h3><p>因为容器化的使用形成了一个串行的链路，所以如果某个关键节点失败，会导致容器功能不可使用，关键指标的任务就是从上述众多的指标当中筛选出这些关键节点。例如在下载链路中bundle下载的成功率和API的成功率，加载链路中bundle加载的成功率和模块匹配的成功率，下载或加载失败都无法再进行链路中的后续步骤，针对上面的成功率指标，我们会添加分钟级别的实时监控告警，做到及时发现，快速响应和紧急修复。</p>
<p>在使用链路中模块渲染的成功率、Native Crash率、JS错误率也属于关键指标，这些任务的失败也会导致容器的不可用，针对这些指标我们也会采用实时监控措施，并且添加降级手段，例如回滚bundle版本，或者把MRN和Mach容器降级为Native容器。</p>
<h2 id="6-外卖容器化架构的监控运维"><a href="#6-外卖容器化架构的监控运维" class="headerlink" title="6. 外卖容器化架构的监控运维"></a>6. 外卖容器化架构的监控运维</h2><p>上面讲到了容器化架构的各项衡量指标，那么把这些指标具体落到实处的工作就是线上的运维监控工作。工欲善其事，必先利其器，对于监控运维工作，一定要有合适的监控工具辅助配合才能事半功倍，公司内有很多优秀的监控统计工具可供使用，这里的难点就是如何根据监控的需要判断选择合适的工具。还有就是合理的划分监控维度和数据指标的优先级，例如对于能够影响到链路稳定性的关键指标，我们需要做到分钟级的监控，一旦出现问题就能及时收到告警，对于非关键指标，则通过生成日报的方式，方便开发者的统计和分析。</p>
<p><strong>工具的使用</strong>上主要分为大盘工具、具体异常工具、灰度降级工具、告警工具等（以下是美团内部使用的工具）。</p>
<ul>
<li><strong>大盘工具</strong>：主要使用CAT、天网、Crash平台等工具。这些工具收集、统计大盘数据，然后生成可视化的图标和曲线。方便开发者了解大盘的整体情况和变化趋势。</li>
<li><strong>具体异常工具</strong>：使用Sniffer、Logan等工具。这些工具可以用来获取发生异常时的上下文和设备信息，回捞用户行为日志，方便定位排查具体问题。</li>
<li><strong>灰度降级工具</strong>：使用ABTest平台、Horn等工具。用于下发配置，以进行灰度控制或开关控制。</li>
<li><strong>告警工具</strong>：告警小助手。将告警通过IM软件及时发送到个人或群组，做到及时发现及时处理。</li>
</ul>
<p><strong>业务覆盖维度监控</strong>可以分为全局监控和局部（单业务）监控。</p>
<ul>
<li><strong>全局监控</strong>：监控各项容器化质量指标、性能指标，生成每日报表，方便跟踪监控容器化的整体质量。</li>
<li><strong>局部（单业务）监控</strong>：实时监控每个页面、每个容器的线上数据，做到有问题及时发现，及时定位，及时处理。</li>
</ul>
<p><strong>时间维度监控</strong>：可以按天、小时、分钟的时间维度。天级别的监控主要是一些非关键路径指标，例如一些性能指标，页面加载时间、页面FPS、JS渲染时间等，我们可以按天维度的生成数据报表，已邮件的数据发送日报。当App灰度上线时，我们会开始小时级别的监控，每过半小时通过IM软件向广播一些关键指标，方便开发者跟踪线上数据的稳定性。分钟级别的监控则是针对关键指标，观察分钟维度上的变化，如果关键指标超过阈值，或者波动过大，就会及时产生告警。</p>
<p>下面我们以一个开发者的视角去看一下外卖容器化架构的监控运维系统。从获取信息的方式上可以分为主动查询和被动推送，开发者可以通过监控工具监控全局和局部数据的变化趋势，也可以分析具体异常Case；也可以从IM工具，邮件等收到相关的推送数据，以便及时响应。在控制运维上，开发者可以通过Eva、Horn等美团内部的灰度系统进行灰度发布，当灰度期发现问题的时候，可以及时地通过停止灰度，版本回滚，关闭入口的方式进行降级容灾处理。</p>
<p><img src="https://p1.meituan.net/travelcube/740cf0af822aac57edc2c3088808210c307911.png@2668w_1058h_80q" alt="img"></p>
<h2 id="7-外卖容器化架构的发布能力"><a href="#7-外卖容器化架构的发布能力" class="headerlink" title="7. 外卖容器化架构的发布能力"></a>7. 外卖容器化架构的发布能力</h2><h3 id="7-1-容器化架构发布体系"><a href="#7-1-容器化架构发布体系" class="headerlink" title="7.1 容器化架构发布体系"></a>7.1 容器化架构发布体系</h3><p>容器化使外卖业务具备了强大的动态化能力，但动态化能力又和需要相应的发布能力来支持，发布能力是我们业务开发质量和效率的重要保障，也是我们容器化建设工作过程中的重点环节，这一节主要介绍一下外卖容器化的发布能力。</p>
<p>从发布能力类型的角度看主要可以分为三种类型：（1）容器内容的发布，包括发布整个页面或者发布页面中的局部模块；（2）配置下发，通过API或其他配置平台，下发布局协议、AB测试、样式配置、功能配置、模板配置、容器配置等，大大提高了业务的灵活度和线上验证能力；（3）灰度、降级下发，通过UUID，用户画像等信息做到灰度发布，降级回滚等控制能力。</p>
<p>从发布资源的的角度看主要分为两种：一种是普通的资源，例如发布一个Web页面，或者通过发布新版API来控制页面局部容器的展示与否和展示的位置，同时我们也可以进行一些AB Test操作；另一种是bundle资源，主要是针对MRN容器和Mach容器，每个MRN容器和Mach容器的资源都会先被打包成一个bundle，然后通过发布系统下发到终端，然后终端解析bundle中的代码和资源，最终渲染页面。</p>
<p>从发布阶段的角度看，可以分为测试阶段、上线阶段、灰度阶段和全量阶段，其中上线阶段是最终的环节，我们增加了很多校验和保护手段来尽量保证上线操作的正确性。</p>
<h3 id="7-2-跟版本发布流程"><a href="#7-2-跟版本发布流程" class="headerlink" title="7.2 跟版本发布流程"></a>7.2 跟版本发布流程</h3><p>虽然我们具随时备动态发布能力，但正常的版本迭代还是会存在中，所以外卖这边的节奏是周动态迭代+双周版本迭代，这保证了我们的开发工作有个一清晰的周期。在动态发布阶段中最关键的阶段操作上线阶段。以MRN为例，目前外卖业务中应有70多个bundle，再算上测试环境的bundle就有接近150个bundle，只是管理这些bundle就是一个复杂的工作，况且在进行上线操作时还是涉及发布的目标App、App版本的上下界、MRN版本的上下界等，一不小心就会造成操作失误，所以进行上线操作时需要非常谨慎。</p>
<p>我们针对操作上线阶段进行了事务流水线，通过流水线建立保护措施，一个bundle的上线要经历一个流水线的若干操作。首先，操作人根据上线SOP手册进行若干检查操作，同时编写标准格式的发布说明，然后周知相关核心人员后在操作系统上发起上线申请，Leader和QA收到申请后会进行检查并审批，审批通过后还要避开App使用的高峰期或节假日上线，上线后通过灰度发布观察各项数据指标，指标正常后全量发布。</p>
<p><img src="https://p0.meituan.net/travelcube/440e73e4a876e020b9641f009c871245140737.png@2834w_476h_80q" alt="img"></p>
<h3 id="7-3-bundle资源发布"><a href="#7-3-bundle资源发布" class="headerlink" title="7.3 bundle资源发布"></a>7.3 bundle资源发布</h3><p>bundle是我们最常发布的资源类型，这里再结合发布工具讲解一下bundle的发布过程。MRN和Mach都是以bundle的形式下发到设备终端的，我们在发布bundle的时候主要会用到两个工具，打包工具Talos和发布工具Eva（美团内部工具）。一个bundle的工程文件主要由三个部分组成：配置文件、源代码和资源文件，其中配置文件用于指导Talos对工程文件进行打包，多个bundle可以共享一份配置文件。当我们准备发布一个bundle时，先找到该bundle在Talos的发布模板，选择发布环境（测试或线上），然后进行一键打包，然后Talos会进行一系列流水线操作，包括Clone代码、配置环境、进行Lint检查、构建和上传等。Talos打包完毕后将bundle上传到Eva系统，然后Eva负责bundle的分包、上线、下线、灰度等操作，最终下发到终端设备上。</p>
<p>未来，我们还将引入美团住宿的MRN-DevOps来进一步的屏蔽当前多系统的问题，降低整个周期管理的成本，特别是发布前的人工检查成本，逐渐实现RD在一个平台上操作从研发到发布运维的所有实现。尽可能地减少人工成本，提升自动化。</p>
<p><img src="https://p0.meituan.net/travelcube/170135afb2188fc3d5b4154e2f2eadcd84337.png@2478w_310h_80q" alt="img"></p>
<h3 id="7-4-多种发布能力综合使用"><a href="#7-4-多种发布能力综合使用" class="headerlink" title="7.4 多种发布能力综合使用"></a>7.4 多种发布能力综合使用</h3><p>上面介绍的是以bundle资源形式的发布流程，过程较为清晰简单。下面再结合外卖首页，介绍一下局部容器化的发布方式。外卖首页是典型的流式列表，在局部容器化的架构下，首页就是由一个个矩形容器以ListView方式布局的，容器分两种，Native容器和Mach容器，Mach容器是一个通用容器，我们可以编写不同的样式模板，下发到终端后交由通用Mach容器来渲染，以此达到只使用通用容器展示不同UI样式的目的，这里涉及了Mach的发布系统。</p>
<p>首页各子容器相当于一块块积木，它们的位置排布、展示与否、模板的选择等最终交由API控制，API具备了控制首页布局，样式展示的能力，而不再是单纯的数据源。同时，首页也涉及了AB能力、灰度降级策略等其实配置项下发系统。可以看到外卖首页的容器化是由多种发布能力配合支撑的，是外卖发布能力体系的“集大成者”。</p>
<p><img src="https://p0.meituan.net/travelcube/4344191360fa345f3027e30f62b769cd206734.png@2426w_676h_80q" alt="img"></p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>好的架构是要随着业务的发展，不断演变去适应业务的发展。美团外卖从一个很小规模，每日单量只有几千的业务，逐渐地走到今天，每日单量峰值超过4000万，组织架构也从一个十几个人的团队，逐渐发展到现在多角色、多垂直业务方向，上千人共同协作的团队。移动端上的架构，为了适应业务的发展要求，也经历了组件化、平台化、RN混合化，再到现在向容器化的变迁。</p>
<p>容器化架构相对于传统的移动端架构而言，充分地利用了现在的跨端技术，将动态化的能力最大化的赋予业务。通过动态化，带来业务迭代周期缩短、编译的加速、开发效率的提升等好处。同时，也解决了我们面临着的多端复用、平台能力、平台支撑、单页面多业务团队、业务动态诉求强等业务问题。</p>
<p>当然，容器化架构带来好处的同时，对线上的可用性、容器的可用性、支撑业务的线上发布上提出了更加严格的要求。我们通过监控下载、加载、使用链路上的可用性，来保障线上动态业务的可用性。针对容器，我们利用成熟的测试基建，建设容器的自动化测试来保障容器的可用性。针对发布，我们建设迭代流程，配合发布流水线，将线上的发布变得更为可控。</p>
<p>截止到目前为止，外卖业务经过了几十个动态化业务上线窗口，累积共发版百次以上。未来半年，我们还将进一步从业务需求入手，将业务需求细分归类，让产品侧逐渐建立容器和动态化需求的概念，能够从源头上，逐渐的将业务进行划分，最终使得每个业务需求，都可以归类抽象成可以动态下发的业务和容器能力建设，从而进一步的完善容器化架构的能力和支持更多的的业务场景。</p>
<h2 id="9-参考资料"><a href="#9-参考资料" class="headerlink" title="9. 参考资料"></a>9. 参考资料</h2><ul>
<li><a href="https://tech.meituan.com/2019/12/19/meituan-mrn-practice.html" target="_blank" rel="noopener">React Native在美团外卖客户端的实践</a></li>
<li><a href="https://tech.meituan.com/2018/06/29/ios-multiterminal-reuse.html" target="_blank" rel="noopener">美团外卖iOS多端复用的推动、支撑与思考</a></li>
<li><a href="https://tech.meituan.com/2019/11/28/meituan-front-end-containerization-evolution.html" target="_blank" rel="noopener">美团外卖前端容器化演进实践</a></li>
<li><a href="https://www.itslide.com/slide/260163/" target="_blank" rel="noopener">UC浏览器客户端容器化架构演进</a></li>
<li><a href="http://www.liuhaihua.cn/archives/585608.html" target="_blank" rel="noopener">你知道支付宝容器化架构是怎么搭建的吗？</a></li>
<li><a href="https://blog.csdn.net/c10WTiybQ1Ye3/article/details/103306331" target="_blank" rel="noopener">讲一讲移动端跨平台技术的演进之路</a></li>
<li><a href="http://www.52im.net/thread-2641-1-1.html" target="_blank" rel="noopener">盘点主流移动端跨平台UI技术：实现原理、技术优劣、横向对比等</a></li>
</ul>
<h2 id="10-作者简介"><a href="#10-作者简介" class="headerlink" title="10.作者简介"></a>10.作者简介</h2><ul>
<li>郭赛，同同，徐宏，均为美团外卖iOS工程师。</li>
</ul>
<h2 id="11-招聘信息"><a href="#11-招聘信息" class="headerlink" title="11. 招聘信息"></a>11. 招聘信息</h2><p>美团外卖长期招聘Android、iOS、FE高级/资深工程师和技术专家，欢迎有兴趣的同学投递简历到<a href="mailto:wangxiaofei03@meituan.com">wangxiaofei03@meituan.com</a>。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zkdingme.github.io/2020/11/13/%E5%A4%96%E5%8D%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%B9%E5%99%A8%E5%8C%96%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/" data-id="ckqi0khpb002znfj58g1wgjd8"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/" rel="tag">容器化</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-CCF2019" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/13/CCF2019/"
    >CCF推荐会议2019</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/11/13/CCF2019/" class="article-date">
  <time datetime="2020-11-13T08:54:35.000Z" itemprop="datePublished">2020-11-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE/">学术会议</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <embed src="ccf2019.pdf" width="100%" height="960">

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zkdingme.github.io/2020/11/13/CCF2019/" data-id="ckqi0kho30005nfj5fkij15fd"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CCF%E6%8E%A8%E8%8D%90%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE2019/" rel="tag">CCF推荐学术会议2019</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020-2021
        Bonjour Ding
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <ul class="list-inline">
  <li>PV:<span id="busuanzi_value_page_pv"></span></li>
  <li>UV:<span id="busuanzi_value_site_uv"></span></li>
</ul>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/favicon.ico" alt="丁星乐"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2020/01/31/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>
<script>
  var typed = new Typed("#subtitle", {
    strings: ['芒焰藏于简单之中','江山如此多娇','会当击水三千里，自信人生二百年'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
</script>




<script>
  var ayerConfig = {
    mathjax: true
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>



<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>